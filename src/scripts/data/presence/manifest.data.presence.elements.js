/* Manifest Data Sources - Presence Element Utilities */

// Generate a unique ID for an element if it doesn't have one
function getElementId(element, containerElement) {
    if (!element) return null;
    if (element.id) return element.id;
    if (element.dataset && element.dataset.presenceId) return element.dataset.presenceId;
    // Generate a stable ID based on element's position in DOM
    const path = [];
    let current = element;
    while (current && current !== containerElement && current !== document.body) {
        const parent = current.parentElement;
        if (parent) {
            const index = Array.from(parent.children).indexOf(current);
            path.unshift(`${current.tagName.toLowerCase()}:${index}`);
        }
        current = parent;
    }
    return path.join('>') || null;
}

// Helper function to find element by ID (supports id, data-presence-id, and DOM path)
function findElementById(elementId, containerElement) {
    if (!elementId) return null;
    // Try by ID first
    let targetElement = document.getElementById(elementId);
    if (targetElement && containerElement.contains(targetElement)) return targetElement;
    // Try by data-presence-id
    targetElement = document.querySelector(`[data-presence-id="${elementId}"]`);
    if (targetElement && containerElement.contains(targetElement)) return targetElement;
    // Try to find by DOM path (generated by getElementId)
    // IMPORTANT: getElementId counts ALL children, not filtered by tagName
    if (elementId.includes('>')) {
        const pathParts = elementId.split('>');
        let current = containerElement;
        for (const part of pathParts) {
            if (!current) break;
            const [tagName, indexStr] = part.split(':');
            const index = parseInt(indexStr, 10);
            if (isNaN(index)) break;
            // Count ALL children (not filtered), matching getElementId behavior
            const allChildren = Array.from(current.children);
            if (index >= 0 && index < allChildren.length) {
                const child = allChildren[index];
                // Verify tagName matches (safety check)
                if (child.tagName.toLowerCase() === tagName.toLowerCase()) {
                    current = child;
                } else {
                    console.warn(`[Presence Debug] TagName mismatch at path step "${part}": expected ${tagName}, got ${child.tagName.toLowerCase()}`);
                    current = null;
                    break;
                }
            } else {
                console.warn(`[Presence Debug] Index out of bounds at path step "${part}": index ${index}, children count ${allChildren.length}`);
                current = null;
                break;
            }
        }
        if (current && containerElement.contains(current)) return current;
    }
    return null;
}

// Helper function to apply visual indicators for a user's presence state
function applyVisualIndicators(userId, focus, selection, editing, userColor, containerElement) {
    const color = userColor || getUserColor(userId);

    // Apply focus indicator
    if (focus && focus.elementId) {
        const targetElement = findElementById(focus.elementId, containerElement);
        if (targetElement) {
            targetElement.classList.add('presence-focused');
            targetElement.setAttribute('data-presence-focus-user', userId);
            targetElement.setAttribute('data-presence-focus-color', color);
        } else {
        }
    }

    // Apply selection indicator
    if (selection && selection.elementId) {
        const targetElement = findElementById(selection.elementId, containerElement);
        if (targetElement) {
            const start = selection.start !== undefined ? selection.start : (selection.startOffset || 0);
            const end = selection.end !== undefined ? selection.end : (selection.endOffset || start);
            targetElement.setAttribute('data-presence-selection-user', userId);
            targetElement.setAttribute('data-presence-selection-start', start.toString());
            targetElement.setAttribute('data-presence-selection-end', end.toString());
            targetElement.setAttribute('data-presence-selection-color', color);
            // Trigger custom event for selection rendering
            targetElement.dispatchEvent(new CustomEvent('presence:selection', {
                detail: { userId, selection: { start, end }, color }
            }));
        }
    }

    // Apply caret indicator
    if (editing && editing.elementId && editing.caretPosition !== null && editing.caretPosition !== undefined) {
        const targetElement = findElementById(editing.elementId, containerElement);
        if (targetElement) {
            targetElement.setAttribute('data-presence-caret-user', userId);
            targetElement.setAttribute('data-presence-caret-position', editing.caretPosition.toString());
            targetElement.setAttribute('data-presence-caret-color', color);
            // Trigger custom event for caret rendering
            targetElement.dispatchEvent(new CustomEvent('presence:caret', {
                detail: { userId, caretPosition: editing.caretPosition, color }
            }));
        }
    }
}

// Helper function to update element value (agnostic for input/textarea/contenteditable)
function updateElementValue(targetElement, newValue, caretPosition) {
    if (!targetElement) return false;

    try {
        // Check if element is editable
        const isEditable = targetElement.tagName === 'INPUT' ||
            targetElement.tagName === 'TEXTAREA' ||
            targetElement.isContentEditable;

        if (!isEditable) return false;

        // Temporarily disable input event to prevent infinite loop
        const wasDisabled = targetElement.hasAttribute('data-presence-syncing');
        targetElement.setAttribute('data-presence-syncing', 'true');

        // Update value based on element type
        if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') {
            const currentValue = targetElement.value || '';
            if (currentValue !== newValue) {
                targetElement.value = newValue;
                // Set caret position if provided
                if (caretPosition !== null && caretPosition !== undefined &&
                    targetElement.setSelectionRange) {
                    try {
                        targetElement.setSelectionRange(caretPosition, caretPosition);
                    } catch (e) {
                        // Some input types don't support setSelectionRange
                    }
                }
                // Trigger input event for reactivity (but mark it as synced)
                const inputEvent = new Event('input', { bubbles: true });
                targetElement.dispatchEvent(inputEvent);
            }
        } else if (targetElement.isContentEditable) {
            const currentValue = targetElement.textContent || '';
            if (currentValue !== newValue) {
                targetElement.textContent = newValue;
                // Try to set caret position for contenteditable
                if (caretPosition !== null && caretPosition !== undefined) {
                    try {
                        const range = document.createRange();
                        const selection = window.getSelection();
                        const textNode = targetElement.firstChild;
                        if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                            const pos = Math.min(caretPosition, textNode.textContent.length);
                            range.setStart(textNode, pos);
                            range.setEnd(textNode, pos);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                    } catch (e) {
                        // Ignore caret positioning errors
                    }
                }
            }
        }

        // Remove sync flag after a short delay
        setTimeout(() => {
            targetElement.removeAttribute('data-presence-syncing');
        }, 50);

        return true;
    } catch (e) {
        console.warn('[Manifest Presence] Failed to update element value:', e);
        targetElement.removeAttribute('data-presence-syncing');
        return false;
    }
}
